<!DOCTYPE html>
<html>

<head>
    <title>Remote Control Test</title>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
    <script src="http://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        .container {
            margin: 20px;
        }

        .section {
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ccc;
        }

        .response {
            margin: 10px 0;
            padding: 10px;
            background: #f5f5f5;
        }

        .error {
            color: red;
        }

        .success {
            color: green;
        }

        #screen {
            max-width: 800px;
            border: 1px solid #ccc;
            margin: 10px 0;
        }

        .input-actions {
            margin: 10px 0;
        }

        .input-actions button {
            margin: 5px;
        }

        .status-connected {
            color: green;
            font-weight: bold;
        }

        .status-disconnected {
            color: red;
            font-weight: bold;
        }

        .session-info {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
        }

        .data-received {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #4CAF50;
        }

        .webrtc-status {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .webrtc-status div {
            margin: 5px 0;
        }
        .webrtc-status .connected {
            color: green;
        }
        .webrtc-status .disconnected {
            color: red;
        }

        .screen-container {
            max-width: 800px;
            border: 1px solid #ccc;
            margin: 10px 0;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f5f5f5;
        }
        .screen-container video,
        .screen-container img {
            max-width: 100%;
            height: auto;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h2>Remote Control Test</h2>

        <!-- Authentication -->
        <div class="section">
            <h3>Authentication</h3>
            <input type="text" id="username" placeholder="Username">
            <input type="password" id="password" placeholder="Password">
            <button onclick="login()">Login</button>
            <button onclick="register()">Register</button>
            <div id="authResponse" class="response"></div>
        </div>

        <!-- Session Management -->
        <div class="section">
            <h3>Session Management</h3>
            <input type="text" id="sessionId" placeholder="Session ID">
            <button onclick="startSession()">Start Session</button>
            <button onclick="joinSession()">Join Session</button>
            <button onclick="leaveSession()">Leave Session</button>
            <button onclick="connectToSession()">Connect</button>
            <button onclick="disconnectFromSession()">Disconnect</button>
            <button onclick="getActiveSessions()">Get Active Sessions</button>
            <div id="sessionResponse" class="response"></div>

            <!-- Active Sessions -->
            <div class="section">
                <h4>Active Sessions</h4>
                <div id="activeSessionsResponse" class="response"></div>
            </div>

            <!-- Active Session Info -->
            <div id="sessionInfo" class="session-info" style="display: none;">
                <h4>Current Session Information</h4>
                <div>Session ID: <span id="activeSessionId"></span></div>
                <div>Role: <span id="sessionRole"></span></div>
                <div>Status: <span id="sessionStatus"></span></div>
                <div>Connected Since: <span id="connectedSince"></span></div>
                <div>Connection ID: <span id="connectionId"></span></div>
            </div>
        </div>

        <!-- Remote Control Actions -->
        <div class="section">
            <h3>Remote Control Actions</h3>
            <div class="input-actions">
                <button onclick="sendInput('keypress', 'A')">Send Key A</button>
                <button onclick="sendInput('keypress', 'B')">Send Key B</button>
                <button onclick="sendInput('mouseclick', 'left')">Mouse Left Click</button>
                <button onclick="sendInput('mousemove', '100,100')">Mouse Move</button>
            </div>
            <div id="inputResponse" class="response"></div>
        </div>

        <!-- Screen Data -->
        <div class="section">
            <h3>Basic Screen Sharing</h3>
            <div class="screen-sharing-controls">
                <button onclick="startScreenSharing()">Start Basic Screen Sharing</button>
                <button onclick="stopScreenSharing()">Stop Basic Screen Sharing</button>
                <button onclick="getScreen()">Get Screen</button>
                <button onclick="updateScreen()">Update Screen (Test)</button>
            </div>
            <div id="basicScreen" class="screen-container"></div>
            <div id="screenResponse" class="response"></div>
        </div>

        <!-- Connection Status -->
        <div class="section">
            <h3>Connection Status</h3>
            <div id="connectionStatus" class="status-disconnected">Disconnected</div>
            <div>Last Activity: <span id="lastActivity">Never</span></div>
            <div>Data Received: <span id="dataReceivedCount">0</span></div>
            <div>Connection State: <span id="connectionState">Disconnected</span></div>
            <button onclick="clearLogs()" style="margin: 10px 0;">Clear Logs</button>
            <div id="logs" class="response"></div>
        </div>

        <!-- Test Connection -->
        <div class="section">
            <h3>Test Connection</h3>
            <button onclick="testHubConnection()">Test Hub Connection</button>
        </div>

        <!-- WebRTC Screen Sharing -->
        <div class="section">
            <h3>WebRTC Screen Sharing</h3>
            <div class="webrtc-status">
                <div>ICE Connection State: <span id="iceConnectionState">disconnected</span></div>
                <div>Signaling State: <span id="signalingState">closed</span></div>
                <div>Data Channel State: <span id="dataChannelState">closed</span></div>
            </div>
            <div class="screen-sharing-controls">
                <button onclick="startWebRTCScreenSharing()">Start WebRTC Screen Sharing</button>
                <button onclick="stopWebRTCScreenSharing()">Stop WebRTC Screen Sharing</button>
            </div>
            <div id="webrtcScreen" class="screen-container"></div>
            <div id="webrtcResponse" class="response"></div>
        </div>

        <!-- File Transfer Section -->
        <div class="section">
            <h3>File Transfer</h3>
            <div class="file-transfer-controls">
                <input type="file" id="fileInput" style="display: none;">
                <button onclick="document.getElementById('fileInput').click()">Select File</button>
                <button onclick="startFileTransfer()">Start Transfer</button>
                <button onclick="cancelFileTransfer()">Cancel Transfer</button>
                <button id="downloadButton" onclick="downloadCompletedFile()" style="display: none;">Download File</button>
            </div>
            <div id="fileTransferProgress" class="progress-bar" style="display: none;">
                <div class="progress-fill"></div>
                <span class="progress-text">0%</span>
            </div>
            <div id="fileTransferStatus" class="response"></div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'http://localhost:5030';
        const HUB_URL = `${API_BASE_URL}/remotecontrolhub`;
        let token = null;
        let connection = null;
        let dataReceivedCount = 0;
        let connectedSince = null;

        // WebRTC Configuration
        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        let peerConnection = null;
        let dataChannel = null;
        let screenStream = null;

        // File Transfer Variables
        let currentFile = null;
        let currentTransferId = null;
        const CHUNK_SIZE = 1024 * 1024; // 1MB chunks

        // Utility Functions
        function displayResponse(elementId, data, isError = false) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
            element.className = `response ${isError ? 'error' : 'success'}`;
        }

        function clearLogs() {
            const logs = document.getElementById('logs');
            logs.innerHTML = '';
            log('Logs cleared');
        }

        function log(message) {
            const logs = document.getElementById('logs');
            const logEntry = document.createElement('div');
            logEntry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            logs.insertBefore(logEntry, logs.firstChild);

            // Update last activity
            document.getElementById('lastActivity').textContent = new Date().toLocaleTimeString();
        }

        function updateConnectionStatus(isConnected) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.textContent = isConnected ? 'Connected' : 'Disconnected';
            statusElement.className = isConnected ? 'status-connected' : 'status-disconnected';
        }

        function updateSessionInfo(sessionData) {
            const sessionInfo = document.getElementById('sessionInfo');
            if (sessionData) {
                document.getElementById('activeSessionId').textContent = sessionData.sessionId;
                document.getElementById('sessionRole').textContent = sessionData.role;
                document.getElementById('sessionStatus').textContent = sessionData.status;
                document.getElementById('connectedSince').textContent = connectedSince ? connectedSince.toLocaleTimeString() : 'N/A';
                sessionInfo.style.display = 'block';
            } else {
                sessionInfo.style.display = 'none';
            }
        }

        // Authentication Functions
        async function login() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: document.getElementById('username').value,
                        password: document.getElementById('password').value
                    })
                });
                const data = await response.json();
                if (response.ok) {
                    token = data.data.token;
                    displayResponse('authResponse', data);
                    log('Login successful');
                    // Get active sessions after successful login
                    getActiveSessions();
                } else {
                    displayResponse('authResponse', data, true);
                    log(`Login failed: ${data.message}`);
                }
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: "LOGIN_ERROR"
                };
                displayResponse('authResponse', errorResponse, true);
                log(`Login error: ${err.message}`);
            }
        }

        async function register() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/auth/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: document.getElementById('username').value,
                        password: document.getElementById('password').value
                    })
                });
                const data = await response.json();
                if (response.ok) {
                    token = data.data.Token;
                    displayResponse('authResponse', data);
                    log('Registration successful');
                } else {
                    displayResponse('authResponse', data, true);
                    log(`Registration failed: ${data.message}`);
                }
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: "REGISTRATION_ERROR"
                };
                displayResponse('authResponse', errorResponse, true);
                log(`Registration error: ${err.message}`);
            }
        }

        // Session Management Functions
        async function startSession() {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/session/start`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                if (response.ok) {
                    document.getElementById('sessionId').value = data.data.sessionId;
                    connectToHub(data.data.sessionId);
                    log('Session started successfully');
                }
                displayResponse('sessionResponse', data, !response.ok);
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: 'SESSION_START_ERROR'
                };
                displayResponse('sessionResponse', errorResponse, true);
                log(`Session start error: ${err.message}`);
            }
        }

        async function joinSession() {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                const errorResponse = {
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'SESSION_ID_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/session/join/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                if (response.ok) {
                    connectToHub(sessionId);
                    log('Successfully joined session');
                }
                displayResponse('sessionResponse', data, !response.ok);
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: 'SESSION_JOIN_ERROR'
                };
                displayResponse('sessionResponse', errorResponse, true);
                log(`Session join error: ${err.message}`);
            }
        }

        // SignalR Connection
        async function connectToHub(sessionId) {
            try {
                // Check if SignalR is loaded
                if (typeof signalR === 'undefined') {
                    log('SignalR library not loaded. Please check the script inclusion.');
                    return;
                }

                // Create new connection
                connection = new signalR.HubConnectionBuilder()
                    .withUrl(`${HUB_URL}?sessionId=${sessionId}`, {
                        skipNegotiation: false,
                        transport: signalR.HttpTransportType.WebSockets,
                        headers: {
                            'Authorization': `Bearer ${token}`
                        },
                        accessTokenFactory: () => token
                    })
                    .withAutomaticReconnect({
                        nextRetryDelayInMilliseconds: retryContext => {
                            // First retry immediately
                            if (retryContext.previousRetryCount === 0) {
                                return 0;
                            }
                            // Then retry after 2, 5, 10, and 20 seconds
                            return Math.min(1000 * Math.pow(2, retryContext.previousRetryCount), 20000);
                        }
                    })
                    .configureLogging(signalR.LogLevel.Debug)
                    .withHubProtocol(new signalR.JsonHubProtocol())
                    .build();

                // Add connection event handlers
                connection.onreconnecting(error => {
                    log(`[DEBUG] Connection lost. Reconnecting...
                        Error: ${error}
                        State: ${connection.state}
                        Timestamp: ${new Date().toISOString()}`);
                    updateConnectionStatus(false);
                    document.getElementById('connectionState').textContent = 'Reconnecting...';
                });

                connection.onreconnected(connectionId => {
                    log(`[DEBUG] Reconnected successfully:
                        Connection ID: ${connectionId}
                        State: ${connection.state}
                        Timestamp: ${new Date().toISOString()}`);
                    updateConnectionStatus(true);
                    document.getElementById('connectionState').textContent = 'Connected';
                    document.getElementById('connectionId').textContent = connectionId;
                });

                connection.onclose(error => {
                    log(`[DEBUG] Connection closed:
                        Error: ${error}
                        State: ${connection.state}
                        Timestamp: ${new Date().toISOString()}`);
                    updateConnectionStatus(false);
                    updateSessionInfo(null);
                    document.getElementById('connectionState').textContent = 'Disconnected';
                    document.getElementById('connectionId').textContent = 'N/A';
                });

                // Add message handlers
                connection.on("Error", (message) => {
                    log(`[ERROR] Received error from server: ${message}`);
                    displayResponse('sessionResponse', {
                        success: false,
                        message: message,
                        code: 'SERVER_ERROR'
                    }, true);
                });

                let connectionEstablished = false;
                connection.on("ConnectionEstablished", (connectionId) => {
                    log(`[DEBUG] Connection established with ID: ${connectionId}`);
                    connectionEstablished = true;
                    updateConnectionStatus(true);
                    document.getElementById('connectionState').textContent = 'Connected';
                    document.getElementById('connectionId').textContent = connectionId;

                    // Register FileTransferCompleted handler after connection is established
                    log(`[DEBUG] Registering FileTransferCompleted event handler`);
                    connection.on("FileTransferCompleted", async (transferId) => {
                        log(`[DEBUG] FileTransferCompleted event received for transfer ID: ${transferId}`);
                        log(`[DEBUG] Current transfer ID: ${currentTransferId}`);
                        log(`[DEBUG] Connection state: ${connection.state}`);
                        log(`[DEBUG] Connection ID: ${connection.connectionId}`);
                        log(`[DEBUG] Event handler timestamp: ${new Date().toISOString()}`);
                        
                        // Check if this client is the sender or receiver
                        const isSender = currentTransferId === transferId;
                        log(`[DEBUG] Client role: ${isSender ? 'Sender' : 'Receiver'}`);
                        
                        if (isSender) {
                            // Sender just needs to clean up
                            log(`[DEBUG] Sender: Cleaning up transfer ${transferId}`);
                            displayResponse('fileTransferStatus', {
                                success: true,
                                message: 'File transfer completed successfully',
                                code: 'TRANSFER_COMPLETED'
                            });
                            cancelFileTransfer();
                        } else {
                            // Receiver: Show download button
                            log(`[DEBUG] Receiver: File transfer completed, showing download button`);
                            currentTransferId = transferId; // Set the transfer ID for the download
                            document.getElementById('downloadButton').style.display = 'inline-block';
                            displayResponse('fileTransferStatus', {
                                success: true,
                                message: 'File transfer completed. Click the Download File button to download.',
                                code: 'TRANSFER_COMPLETED'
                            });
                        }
                    });
                });

                connection.on("PeerConnected", (connectionId) => {
                    log(`[DEBUG] Peer connected: ${connectionId}`);
                });

                connection.on("PeerDisconnected", (connectionId) => {
                    log(`[DEBUG] Peer disconnected: ${connectionId}`);
                });

                connection.on("ReceiveInput", (serializedAction) => {
                    try {
                        log(`[DEBUG] Received input action: ${serializedAction}`);
                        const action = JSON.parse(serializedAction);
                        
                        if (!action || !action.type || !action.action) {
                            throw new Error('Invalid input action format');
                        }

                        log(`[DEBUG] Parsed action details:
                            Type: ${action.type}
                            Action: ${action.action}
                            Key: ${action.key || 'N/A'}
                            Modifiers: ${JSON.stringify(action.modifiers || [])}
                            X: ${action.x || 'N/A'}
                            Y: ${action.y || 'N/A'}
                            Button: ${action.button || 'N/A'}
                            Full Action: ${JSON.stringify(action, null, 2)}`);

                        // Add a small delay to ensure proper handling
                        setTimeout(() => {
                            try {
                                if (action.type === "keyboard") {
                                    log(`[DEBUG] Processing keyboard action: ${action.action} ${action.key}`);
                                    simulateKeyPress(action.key, action.modifiers || []);
                                }
                                else if (action.type === "mouse") {
                                    log(`[DEBUG] Processing mouse action: ${action.action} at (${action.x}, ${action.y})`);
                                    if (action.action === "move") {
                                        simulateMouseMove(action.x, action.y);
                                    } else if (action.action === "click") {
                                        simulateMouseClick(action.x, action.y, action.button);
                                    } else {
                                        throw new Error(`Unsupported mouse action: ${action.action}`);
                                    }
                                } else {
                                    throw new Error(`Unsupported input type: ${action.type}`);
                                }
                            } catch (simError) {
                                log(`[ERROR] Error simulating input: ${simError.message}`);
                                // Notify server about the error
                                connection.invoke("ReportInputError", {
                                    error: simError.message,
                                    action: action
                                }).catch(err => log(`[ERROR] Failed to report input error: ${err.message}`));
                            }
                        }, 100); // Small delay to ensure proper sequencing
                    } catch (error) {
                        log(`[ERROR] Error processing input: ${error.message}`);
                        log(`[ERROR] Raw serialized action: ${serializedAction}`);
                        // Notify server about the error
                        connection.invoke("ReportInputError", {
                            error: error.message,
                            rawAction: serializedAction
                        }).catch(err => log(`[ERROR] Failed to report input error: ${err.message}`));
                    }
                });

                connection.on("ScreenDataUpdated", (imageData) => {
                    dataReceivedCount++;
                    document.getElementById('dataReceivedCount').textContent = dataReceivedCount;

                    log(`[DEBUG] Received screen update:
                        Data length: ${imageData.length}
                        First 100 chars: ${imageData.substring(0, 100)}...`);
                    
                    const img = document.createElement('img');
                    img.src = `data:image/jpeg;base64,${imageData}`;
                    document.getElementById('basicScreen').innerHTML = '';
                    document.getElementById('basicScreen').appendChild(img);
                });

                connection.on("TestMessage", (message) => {
                    log(`[DEBUG] Received test message:
                        Message: ${message}
                        Type: ${typeof message}
                        Timestamp: ${new Date().toISOString()}`);
                });

                connection.on("Echo", (message) => {
                    log(`[DEBUG] Received echo:
                        Message: ${message}
                        Type: ${typeof message}
                        Timestamp: ${new Date().toISOString()}`);
                });

                // Add WebRTC signal handlers
                connection.on("ReceiveWebRTCSignal", async (signal) => {
                    try {
                        // Create peer connection if it doesn't exist
                        if (!peerConnection) {
                            log('Creating new peer connection for receiving signals');
                            peerConnection = new RTCPeerConnection({
                                iceServers: [
                                    { urls: 'stun:stun.l.google.com:19302' },
                                    { urls: 'stun:stun1.l.google.com:19302' }
                                ],
                                iceCandidatePoolSize: 10,
                                bundlePolicy: 'max-bundle',
                                rtcpMuxPolicy: 'require',
                                iceTransportPolicy: 'all'
                            });

                            // Set up peer connection event handlers
                            peerConnection.onicecandidate = async (event) => {
                                if (event.candidate) {
                                    await sendWebRTCSignal('ice-candidate', JSON.stringify(event.candidate));
                                }
                            };

                            peerConnection.onconnectionstatechange = () => {
                                const state = peerConnection.connectionState;
                                document.getElementById('iceConnectionState').textContent = state;
                                document.getElementById('iceConnectionState').className = 
                                    state === 'connected' ? 'connected' : 'disconnected';
                                
                                if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                                    log(`WebRTC connection ${state}, attempting to restart...`);
                                    stopWebRTCScreenSharing();
                                    setTimeout(() => startWebRTCScreenSharing(), 2000);
                                }
                            };

                            peerConnection.onsignalingstatechange = () => {
                                const state = peerConnection.signalingState;
                                document.getElementById('signalingState').textContent = state;
                                log(`WebRTC signaling state changed to: ${state}`);
                            };

                            peerConnection.oniceconnectionstatechange = () => {
                                const state = peerConnection.iceConnectionState;
                                log(`ICE connection state changed to: ${state}`);
                            };

                            peerConnection.onicegatheringstatechange = () => {
                                const state = peerConnection.iceGatheringState;
                                log(`ICE gathering state changed to: ${state}`);
                            };

                            // Set up video track handler
                            peerConnection.ontrack = (event) => {
                                const videoElement = document.createElement('video');
                                videoElement.autoplay = true;
                                videoElement.playsInline = true;
                                videoElement.style.width = '100%';
                                videoElement.style.height = 'auto';
                                videoElement.style.maxWidth = '100%';
                                videoElement.style.objectFit = 'contain';
                                
                                if (event.streams && event.streams[0]) {
                                    const stream = event.streams[0];
                                    videoElement.srcObject = stream;
                                    
                                    stream.onended = () => {
                                        log('Remote stream ended');
                                        stopWebRTCScreenSharing();
                                    };
                                }

                                const screenElement = document.getElementById('webrtcScreen');
                                screenElement.innerHTML = '';
                                screenElement.appendChild(videoElement);
                                
                                log('Remote video stream received and displayed');
                            };
                        }

                        log(`Received WebRTC ${signal.signalType} signal from ${signal.fromConnectionId}`);

                        switch (signal.signalType) {
                            case 'offer':
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(signal.signalData)));
                                const answer = await peerConnection.createAnswer({
                                    offerToReceiveVideo: true,
                                    offerToReceiveAudio: false
                                });
                                await peerConnection.setLocalDescription(answer);
                                await sendWebRTCSignal('answer', JSON.stringify(answer));
                                break;

                            case 'answer':
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(signal.signalData)));
                                break;

                            case 'ice-candidate':
                                if (peerConnection.remoteDescription) {
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(JSON.parse(signal.signalData)));
                                } else {
                                    log('Received ICE candidate before remote description, will be added when remote description is set');
                                }
                                break;
                        }

                        log(`WebRTC ${signal.signalType} signal processed successfully`);
                    } catch (error) {
                        log(`Error processing WebRTC signal: ${error.message}`);
                        // If there's an error, clean up the peer connection
                        if (peerConnection) {
                            stopWebRTCScreenSharing();
                        }
                    }
                });

                connection.on("ReceiveWebRTCState", (state) => {
                    try {
                        log(`Received WebRTC state update from ${state.fromConnectionId}: ${state.state}`);
                        
                        // Update UI with state
                        document.getElementById('iceConnectionState').textContent = state.state;
                        document.getElementById('iceConnectionState').className = 
                            state.state === 'connected' ? 'connected' : 'disconnected';
                        
                        if (state.state === 'failed' || state.state === 'disconnected' || state.state === 'closed') {
                            log(`WebRTC connection ${state.state}, attempting to restart...`);
                            stopWebRTCScreenSharing();
                            setTimeout(() => startWebRTCScreenSharing(), 2000);
                        }
                    } catch (error) {
                        log(`Error processing WebRTC state: ${error.message}`);
                    }
                });

                log(`Connecting to hub at: ${HUB_URL}`);
                log(`Using session ID: ${sessionId}`);
                log(`Using token: ${token ? 'Token present' : 'No token'}`);

                // Start the connection
                log('Starting connection...');
                await connection.start();
                log('Connection started successfully');
                updateConnectionStatus(true);
                document.getElementById('connectionState').textContent = 'Connected';
                document.getElementById('connectionId').textContent = connection.connectionId || 'N/A';

                // Wait for connection to be fully established
                let retryCount = 0;
                const maxRetries = 5;
                const checkInterval = 1000; // 1 second

                while (retryCount < maxRetries) {
                    if (connectionEstablished && connection.state === signalR.HubConnectionState.Connected) {
                        log('Connection is fully established and synchronized');
                        break;
                    }

                    log(`Waiting for connection to be fully established... Attempt ${retryCount + 1}/${maxRetries}`);
                    log(`Current state: ${connection.state}, Connection established: ${connectionEstablished}`);
                    await new Promise(resolve => setTimeout(resolve, checkInterval));
                    retryCount++;
                }

                if (!connectionEstablished || connection.state !== signalR.HubConnectionState.Connected) {
                    throw new Error(`Failed to establish connection after ${maxRetries} attempts. Current state: ${connection.state}, Connection established: ${connectionEstablished}`);
                }

                // Send a test message to verify connection
                const testAction = {
                    type: "test",
                    action: "test",
                    message: "Testing connection..."
                };

                log('Sending test message...');
                await connection.invoke("SendInputAction", sessionId, JSON.stringify(testAction));
                log('Test message sent successfully');
                displayResponse('sessionResponse', {
                    success: true,
                    message: 'Test message sent successfully',
                    code: 'TEST_SUCCESS'
                });
            } catch (err) {
                log(`Hub connection error: ${err}`);
                updateConnectionStatus(false);
                document.getElementById('connectionState').textContent = 'Connection Failed';
                displayResponse('sessionResponse', {
                    success: false,
                    message: `Connection failed: ${err.message}`,
                    code: 'CONNECTION_FAILED'
                }, true);
            }
        }

        // Remote Control Functions
        async function sendInput(type, value) {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                };
                displayResponse('inputResponse', errorResponse, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                const errorResponse = {
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'SESSION_ID_REQUIRED'
                };
                displayResponse('inputResponse', errorResponse, true);
                return;
            }

            let inputData;
            if (type.startsWith('key')) {
                inputData = {
                    type: "keyboard",
                    action: "keydown",
                    key: value,
                    modifiers: []
                };
            } else if (type.startsWith('mouse')) {
                if (type === 'mouseclick') {
                    inputData = {
                        type: "mouse",
                        action: "click",
                        x: 100,
                        y: 100,
                        button: value
                    };
                } else if (type === 'mousemove') {
                    const [x, y] = value.split(',').map(Number);
                    inputData = {
                        type: "mouse",
                        action: "move",
                        x: x,
                        y: y
                    };
                }
            }

            try {
                log(`Sending input: ${JSON.stringify(inputData)}`);
                
                // First try to send through SignalR
                if (connection && connection.state === signalR.HubConnectionState.Connected) {
                    log('Sending input through SignalR...');
                    try {
                        const result = await connection.invoke("SendInputAction", sessionId, JSON.stringify(inputData));
                        if (result && result.success === false) {
                            throw new Error(result.message || 'Failed to send input');
                        }
                        log('Input sent through SignalR successfully');
                        displayResponse('inputResponse', {
                            success: true,
                            message: 'Input sent successfully through SignalR',
                            code: 'INPUT_SENT'
                        });
                    } catch (signalRError) {
                        log(`SignalR error: ${signalRError.message}`);
                        throw signalRError; // Re-throw to be caught by outer catch
                    }
                    return;
                }

                // Fallback to REST API if SignalR is not available
                log('SignalR not available, falling back to REST API...');
                const response = await fetch(`${API_BASE_URL}/api/remote/send-input`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sessionIdentifier: sessionId,
                        action: inputData
                    })
                });

                const data = await response.json();
                log(`Server response: ${JSON.stringify(data)}`);

                if (!response.ok || !data.success) {
                    throw new Error(data.message || 'Failed to send input');
                }

                log(`Input sent successfully: ${type} ${value}`);
                displayResponse('inputResponse', data);
            } catch (err) {
                log(`Input send error: ${err.message}`);
                displayResponse('inputResponse', {
                    success: false,
                    message: err.message || 'Failed to send input',
                    code: 'INPUT_SEND_ERROR'
                }, true);
            }
        }

        async function getScreen() {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                };
                displayResponse('screenResponse', errorResponse, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                const errorResponse = {
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'SESSION_ID_REQUIRED'
                };
                displayResponse('screenResponse', errorResponse, true);
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/remote/screen?sessionIdentifier=${sessionId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                if (response.ok) {
                    log('Screen update requested successfully');
                }
                displayResponse('screenResponse', data, !response.ok);
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: 'SCREEN_GET_ERROR'
                };
                displayResponse('screenResponse', errorResponse, true);
                log(`Screen get error: ${err.message}`);
            }
        }

        async function updateScreen() {
            if (!token) {
                displayResponse('screenResponse', { 
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                }, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                displayResponse('screenResponse', { 
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'SESSION_ID_REQUIRED'
                }, true);
                return;
            }

            try {
                // Request screen capture with user gesture
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    }
                }).catch(err => {
                    throw new Error('Screen capture permission denied or cancelled');
                });

                // Create video element to capture frame
                const video = document.createElement('video');
                video.srcObject = stream;
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                // Create canvas and draw frame
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);

                // Convert to JPEG with quality 0.7
                const imageData = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];

                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;

                const screenData = {
                    sessionIdentifier: sessionId,
                    data: imageData,
                    width: canvas.width,
                    height: canvas.height,
                    createdAt: new Date().toISOString()
                };

                const response = await fetch(`${API_BASE_URL}/api/remote/screen`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(screenData)
                });

                const data = await response.json();
                if (response.ok) {
                    log('Screen data sent successfully');
                } else {
                    log(`Screen data send failed: ${data.message}`);
                }
                displayResponse('screenResponse', data, !response.ok);
            } catch (err) {
                displayResponse('screenResponse', { 
                    success: false,
                    message: err.message,
                    code: 'SCREEN_UPDATE_ERROR'
                }, true);
                log(`Screen update error: ${err.message}`);
            }
        }

        // Add screen sharing interval with adaptive frame rate
        let screenSharingInterval = null;
        let lastFrameTime = 0;
        const minFrameInterval = 100; // Minimum time between frames (ms)
        const maxFrameInterval = 1000; // Maximum time between frames (ms)
        let currentFrameInterval = 500; // Start with 2 FPS

        async function startScreenSharing() {
            if (screenSharingInterval) {
                clearInterval(screenSharingInterval);
            }

            try {
                // Request screen capture with user gesture
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    }
                }).catch(err => {
                    throw new Error('Screen capture permission denied or cancelled');
                });

                // Create video element for continuous capture
                const video = document.createElement('video');
                video.srcObject = screenStream;
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                // Update screen with adaptive frame rate
                screenSharingInterval = setInterval(async () => {
                    const now = Date.now();
                    const timeSinceLastFrame = now - lastFrameTime;

                    if (timeSinceLastFrame >= currentFrameInterval) {
                        try {
                            // Create canvas and draw current frame
                            const canvas = document.createElement('canvas');
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(video, 0, 0);

                            // Convert to JPEG with quality 0.7
                            const imageData = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];

                            const screenData = {
                                sessionIdentifier: document.getElementById('sessionId').value,
                                data: imageData,
                                width: canvas.width,
                                height: canvas.height,
                                createdAt: new Date().toISOString()
                            };

                            const response = await fetch(`${API_BASE_URL}/api/remote/screen`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${token}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(screenData)
                            });

                            if (response.ok) {
                                lastFrameTime = now;
                                // Adjust frame rate based on performance
                                if (timeSinceLastFrame < currentFrameInterval * 0.8) {
                                    currentFrameInterval = Math.min(currentFrameInterval * 1.2, maxFrameInterval);
                                } else if (timeSinceLastFrame > currentFrameInterval * 1.2) {
                                    currentFrameInterval = Math.max(currentFrameInterval * 0.8, minFrameInterval);
                                }
                            }
                        } catch (error) {
                            log(`Error in screen sharing: ${error.message}`);
                            currentFrameInterval = Math.min(currentFrameInterval * 1.5, maxFrameInterval);
                        }
                    }
                }, minFrameInterval);

                log('Screen sharing started');
            } catch (error) {
                log(`Error starting screen sharing: ${error.message}`);
                displayResponse('screenResponse', {
                    success: false,
                    message: error.message,
                    code: 'SCREEN_SHARING_ERROR'
                }, true);
            }
        }

        function stopScreenSharing() {
            if (screenSharingInterval) {
                clearInterval(screenSharingInterval);
                screenSharingInterval = null;
            }
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
            }
            currentFrameInterval = 500; // Reset frame rate
            log('Screen sharing stopped');
        }

        // Add leave session function
        async function leaveSession() {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                const errorResponse = {
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'SESSION_ID_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            try {
                // First stop the SignalR connection
                if (connection && connection.state !== signalR.HubConnectionState.Disconnected) {
                    try {
                        await connection.stop();
                    } catch (stopError) {
                        log(`Error stopping connection: ${stopError.message}`);
                    }
                }
                connection = null;

                const response = await fetch(`${API_BASE_URL}/api/session/stop/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    updateConnectionStatus(false);
                    updateSessionInfo(null);
                    document.getElementById('sessionId').value = '';
                    log('Successfully left session');
                }
                displayResponse('sessionResponse', data, !response.ok);
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: 'SESSION_LEAVE_ERROR'
                };
                displayResponse('sessionResponse', errorResponse, true);
                log(`Session leave error: ${err.message}`);
            }
        }

        // Replace refreshActiveSessions with getActiveSessions
        async function getActiveSessions() {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED',
                    data: []
                };
                displayResponse('activeSessionsResponse', errorResponse, true);
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/session/active`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                if (response.ok && data.success) {
                    // Format the response with more details
                    const formattedResponse = {
                        success: true,
                        message: data.message,
                        code: data.code,
                        data: data.data.map(session => ({
                            sessionId: session.sessionId,
                            host: session.hostUsername,
                            client: session.clientUsername,
                            created: new Date(session.createdAt).toLocaleString(),
                            lastActivity: new Date(session.lastActivity).toLocaleString(),
                            status: session.status
                        }))
                    };

                    // Update connection status
                    updateConnectionStatus(true);
                    if (data.data.length > 0) {
                        document.getElementById('sessionId').value = data.data[0].sessionId;
                    }
                    document.getElementById('connectionState').textContent = 'Active Sessions Available';
                    log(`Found ${data.data.length} active sessions`);

                    // Display formatted response
                    displayResponse('activeSessionsResponse', formattedResponse);
                } else {
                    const formattedResponse = {
                        success: false,
                        message: data.message || 'No active sessions found',
                        code: data.code || 'NO_SESSIONS',
                        data: []
                    };

                    updateConnectionStatus(false);
                    document.getElementById('connectionState').textContent = 'No Active Sessions';
                    displayResponse('activeSessionsResponse', formattedResponse);
                }
            } catch (err) {
                const formattedResponse = {
                    success: false,
                    message: `Error fetching sessions: ${err.message}`,
                    code: 'FETCH_ERROR',
                    data: []
                };

                updateConnectionStatus(false);
                document.getElementById('connectionState').textContent = 'Error Fetching Sessions';
                displayResponse('activeSessionsResponse', formattedResponse, true);
            }
        }

        // Add connect and disconnect functions
        async function connectToSession() {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                const errorResponse = {
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'SESSION_ID_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            try {
                // First ensure we have a SignalR connection
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) {
                    log('Establishing SignalR connection first...');
                    await connectToHub(sessionId);
                }

                // Wait a moment to ensure connection is fully established
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (!connection || !connection.connectionId) {
                    throw new Error('No SignalR connection ID available');
                }

                log(`[DEBUG] Connecting to session with SignalR connection ID: ${connection.connectionId}`);

                const response = await fetch(`${API_BASE_URL}/api/session/connect/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        'X-SignalR-Connection-Id': connection.connectionId
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    document.getElementById('connectionId').textContent = data.ConnectionId;
                    updateConnectionStatus(true);
                    document.getElementById('connectionState').textContent = 'Connected';
                    log(`[DEBUG] Successfully connected to session with connection ID: ${data.ConnectionId}`);
                } else {
                    log(`[ERROR] Failed to connect to session: ${data.Message}`);
                }
                displayResponse('sessionResponse', data, !response.ok);
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: 'SESSION_CONNECT_ERROR'
                };
                displayResponse('sessionResponse', errorResponse, true);
                log(`[ERROR] Session connect error: ${err.message}`);
            }
        }

        async function disconnectFromSession() {
            if (!token) {
                const errorResponse = {
                    success: false,
                    message: 'Please login first',
                    code: 'AUTH_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                const errorResponse = {
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'SESSION_ID_REQUIRED'
                };
                displayResponse('sessionResponse', errorResponse, true);
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/session/disconnect/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                if (response.ok) {
                    document.getElementById('connectionId').textContent = 'N/A';
                    updateConnectionStatus(false);
                    document.getElementById('connectionState').textContent = 'Disconnected';
                    log('Successfully disconnected from session');
                }
                displayResponse('sessionResponse', data, !response.ok);
            } catch (err) {
                const errorResponse = {
                    success: false,
                    message: err.message,
                    code: 'SESSION_DISCONNECT_ERROR'
                };
                displayResponse('sessionResponse', errorResponse, true);
                log(`Session disconnect error: ${err.message}`);
            }
        }

        // Update window.onload
        window.onload = function () {
            if (token) {
                getActiveSessions();
            }
        };

        function simulateKeyPress(key, modifiers = []) {
            // Create and dispatch keydown event
            const keyDownEvent = new KeyboardEvent('keydown', {
                key: key,
                code: `Key${key.toUpperCase()}`,
                ctrlKey: modifiers.includes('Control'),
                altKey: modifiers.includes('Alt'),
                shiftKey: modifiers.includes('Shift'),
                metaKey: modifiers.includes('Meta')
            });
            document.dispatchEvent(keyDownEvent);

            // Create and dispatch keyup event
            const keyUpEvent = new KeyboardEvent('keyup', {
                key: key,
                code: `Key${key.toUpperCase()}`,
                ctrlKey: modifiers.includes('Control'),
                altKey: modifiers.includes('Alt'),
                shiftKey: modifiers.includes('Shift'),
                metaKey: modifiers.includes('Meta')
            });
            document.dispatchEvent(keyUpEvent);
        }

        function simulateMouseMove(x, y) {
            const moveEvent = new MouseEvent('mousemove', {
                clientX: x,
                clientY: y,
                bubbles: true
            });
            document.dispatchEvent(moveEvent);
        }

        function simulateMouseClick(x, y, button = 'left') {
            // Mouse down
            const downEvent = new MouseEvent('mousedown', {
                clientX: x,
                clientY: y,
                button: button === 'left' ? 0 : button === 'right' ? 2 : 1,
                bubbles: true
            });
            document.dispatchEvent(downEvent);

            // Mouse up
            const upEvent = new MouseEvent('mouseup', {
                clientX: x,
                clientY: y,
                button: button === 'left' ? 0 : button === 'right' ? 2 : 1,
                bubbles: true
            });
            document.dispatchEvent(upEvent);

            // Click
            const clickEvent = new MouseEvent('click', {
                clientX: x,
                clientY: y,
                button: button === 'left' ? 0 : button === 'right' ? 2 : 1,
                bubbles: true
            });
            document.dispatchEvent(clickEvent);
        }

        async function testHubConnection() {
            try {
                // Check if SignalR is loaded
                if (typeof signalR === 'undefined') {
                    log('SignalR library not loaded. Please check the script inclusion.');
                    displayResponse('sessionResponse', {
                        success: false,
                        message: 'SignalR library not loaded',
                        code: 'SIGNALR_NOT_LOADED'
                    }, true);
                    return;
                }

                if (!token) {
                    log('No authentication token available. Please login first.');
                    displayResponse('sessionResponse', {
                        success: false,
                        message: 'No authentication token available. Please login first.',
                        code: 'NO_TOKEN'
                    }, true);
                    return;
                }

                const sessionId = document.getElementById('sessionId').value;
                if (!sessionId) {
                    log('No session ID available. Please start or join a session first.');
                    displayResponse('sessionResponse', {
                        success: false,
                        message: 'No session ID available. Please start or join a session.',
                        code: 'NO_SESSION_ID'
                    }, true);
                    return;
                }

                // If we already have a connection, test it first
                if (connection && connection.state === signalR.HubConnectionState.Connected) {
                    try {
                        await connection.invoke("Echo", "Test connection");
                        log('Existing connection is working');
                        displayResponse('sessionResponse', {
                            success: true,
                            message: 'Connection is working',
                            code: 'CONNECTION_OK'
                        });
                        return;
                    } catch (error) {
                        log(`Existing connection failed: ${error.message}`);
                        // Continue to create new connection
                    }
                }

                // Create new connection
                log('Creating new connection...');
                connection = new signalR.HubConnectionBuilder()
                    .withUrl(`${HUB_URL}?sessionId=${sessionId}`, {
                        skipNegotiation: false,
                        transport: signalR.HttpTransportType.WebSockets,
                        headers: {
                            'Authorization': `Bearer ${token}`
                        },
                        accessTokenFactory: () => token
                    })
                    .withAutomaticReconnect({
                        nextRetryDelayInMilliseconds: retryContext => {
                            if (retryContext.previousRetryCount === 0) {
                                return 0;
                            }
                            return Math.min(1000 * Math.pow(2, retryContext.previousRetryCount), 20000);
                        }
                    })
                    .configureLogging(signalR.LogLevel.Debug)
                    .withHubProtocol(new signalR.JsonHubProtocol())
                    .build();

                // Add connection event handlers
                connection.onreconnecting(error => {
                    log(`Connection lost. Reconnecting... Error: ${error}`);
                    updateConnectionStatus(false);
                    document.getElementById('connectionState').textContent = 'Reconnecting...';
                });

                connection.onreconnected(connectionId => {
                    log(`Reconnected successfully. Connection ID: ${connectionId}`);
                    updateConnectionStatus(true);
                    document.getElementById('connectionState').textContent = 'Connected';
                    document.getElementById('connectionId').textContent = connectionId;
                });

                connection.onclose(error => {
                    log(`Connection closed. Error: ${error}`);
                    updateConnectionStatus(false);
                    updateSessionInfo(null);
                    document.getElementById('connectionState').textContent = 'Disconnected';
                    document.getElementById('connectionId').textContent = 'N/A';
                });

                // Add message handlers
                connection.on("Error", (message) => {
                    log(`Received error from server: ${message}`);
                    displayResponse('sessionResponse', {
                        success: false,
                        message: message,
                        code: 'SERVER_ERROR'
                    }, true);
                });

                connection.on("ConnectionEstablished", (connectionId) => {
                    log(`Connection established with ID: ${connectionId}`);
                    updateConnectionStatus(true);
                    document.getElementById('connectionState').textContent = 'Connected';
                    document.getElementById('connectionId').textContent = connectionId;
                });

                connection.on("Echo", (message) => {
                    log(`Received echo: ${message}`);
                });

                // Start the connection
                log('Starting connection...');
                await connection.start();
                log('Connection started successfully');

                // Test the connection with an echo
                await connection.invoke("Echo", "Test connection");
                log('Echo test successful');

                updateConnectionStatus(true);
                document.getElementById('connectionState').textContent = 'Connected';
                document.getElementById('connectionId').textContent = connection.connectionId || 'N/A';

                displayResponse('sessionResponse', {
                    success: true,
                    message: 'Connection test successful',
                    code: 'TEST_SUCCESS'
                });
            } catch (error) {
                log(`Error testing connection: ${error.message}`);
                displayResponse('sessionResponse', {
                    success: false,
                    message: `Error testing connection: ${error.message}`,
                    code: 'TEST_CONNECTION_ERROR'
                }, true);
            }
        }

        // WebRTC Functions
        async function startWebRTCScreenSharing() {
            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) {
                    throw new Error('SignalR connection not established');
                }

                const sessionId = document.getElementById('sessionId').value;
                if (!sessionId) {
                    throw new Error('No session ID available');
                }

                // Get the session info to determine peer
                const response = await fetch(`${API_BASE_URL}/api/session/info/${sessionId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    log(`Session info error response: ${errorText}`);
                    throw new Error(`Failed to get session info: ${response.status} ${response.statusText}`);
                }

                let sessionInfo;
                try {
                    const responseText = await response.text();
                    log(`Raw session info response: ${responseText}`);
                    sessionInfo = JSON.parse(responseText);
                } catch (parseError) {
                    log(`Error parsing session info: ${parseError.message}`);
                    throw new Error('Invalid session info response format');
                }

                if (!sessionInfo || !sessionInfo.data) {
                    throw new Error('Invalid session info structure');
                }

                log(`Parsed session info: ${JSON.stringify(sessionInfo)}`);

                // Determine if we are host or client
                const isHost = sessionInfo.data.hostConnectionId === connection.connectionId;
                const peerConnectionId = isHost ? sessionInfo.data.clientConnectionId : sessionInfo.data.hostConnectionId;

                if (!peerConnectionId) {
                    throw new Error('Peer not connected');
                }

                log(`Starting WebRTC with peer: ${peerConnectionId} (${isHost ? 'as host' : 'as client'})`);

                // Generate key pair for this session
                const keyPair = await generateKeyPair();
                const publicKey = await exportPublicKey(keyPair);
                const privateKey = await exportPrivateKey(keyPair);

                // Send public key to peer
                await connection.invoke("ExchangePublicKey", sessionId, peerConnectionId, publicKey);
                log('Public key exchanged');

                // Create peer connection
                peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                // Handle ICE candidates
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        await sendWebRTCSignal('ice-candidate', JSON.stringify(event.candidate));
                    }
                };

                // Get screen stream
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    }
                });

                // Add tracks to peer connection
                screenStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, screenStream);
                });

                // Create and send offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false
                });

                await peerConnection.setLocalDescription(offer);
                await sendWebRTCSignal('offer', JSON.stringify(offer));
                log('WebRTC offer sent');

                // Store private key for later use
                window.currentPrivateKey = privateKey;

                log('WebRTC screen sharing started with encryption');
            } catch (error) {
                log(`Error starting WebRTC screen sharing: ${error.message}`);
                stopWebRTCScreenSharing();
            }
        }

        async function stopWebRTCScreenSharing() {
            try {
                if (screenStream) {
                    screenStream.getTracks().forEach(track => {
                        track.stop();
                        track.enabled = false;
                    });
                    screenStream = null;
                }

                if (dataChannel) {
                    dataChannel.close();
                    dataChannel = null;
                }

                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }

                document.getElementById('iceConnectionState').textContent = 'disconnected';
                document.getElementById('signalingState').textContent = 'closed';
                document.getElementById('dataChannelState').textContent = 'closed';
                document.getElementById('webrtcScreen').innerHTML = '';

                log('WebRTC screen sharing stopped');
            } catch (error) {
                log(`Error stopping WebRTC screen sharing: ${error.message}`);
            }
        }

        async function sendWebRTCSignal(signalType, signalData) {
            try {
                const sessionId = document.getElementById('sessionId').value;
                if (!sessionId) {
                    throw new Error('No session ID available');
                }

                // Format the signal as type:data
                const signal = `${signalType}:${signalData}`;

                // Send through SignalR
                if (connection && connection.state === signalR.HubConnectionState.Connected) {
                    await connection.invoke("SendWebRTCSignal", sessionId, signal);
                    log(`WebRTC ${signalType} signal sent successfully`);
                } else {
                    throw new Error('SignalR connection not available');
                }
            } catch (error) {
                log(`Error sending WebRTC signal: ${error.message}`);
                throw error;
            }
        }

        // File Transfer Functions
        document.getElementById('fileInput').addEventListener('change', function(e) {
            currentFile = e.target.files[0];
            if (currentFile) {
                displayResponse('fileTransferStatus', {
                    success: true,
                    message: `Selected file: ${currentFile.name} (${formatFileSize(currentFile.size)})`,
                    code: 'FILE_SELECTED'
                });
            }
        });

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        async function startFileTransfer() {
            if (!currentFile) {
                displayResponse('fileTransferStatus', {
                    success: false,
                    message: 'Please select a file first',
                    code: 'NO_FILE_SELECTED'
                }, true);
                return;
            }

            if (!connection || connection.state !== signalR.HubConnectionState.Connected) {
                displayResponse('fileTransferStatus', {
                    success: false,
                    message: 'SignalR connection not established',
                    code: 'NO_CONNECTION'
                }, true);
                return;
            }

            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                displayResponse('fileTransferStatus', {
                    success: false,
                    message: 'Please enter a session ID',
                    code: 'NO_SESSION_ID'
                }, true);
                return;
            }

            try {
                // Initiate file transfer
                const response = await fetch(`${API_BASE_URL}/api/filetransfer/initiate?sessionId=${sessionId}&fileName=${encodeURIComponent(currentFile.name)}&fileSize=${currentFile.size}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (!response.ok || !data.success) {
                    throw new Error(data.message || 'Failed to initiate file transfer');
                }

                currentTransferId = data.data.id;
                document.getElementById('fileTransferProgress').style.display = 'block';
                
                // Start sending file chunks
                let offset = 0;
                while (offset < currentFile.size) {
                    const chunk = currentFile.slice(offset, offset + CHUNK_SIZE);
                    const chunkArrayBuffer = await chunk.arrayBuffer();
                    const chunkBytes = new Uint8Array(chunkArrayBuffer);
                    const chunkResponse = await fetch(`${API_BASE_URL}/api/filetransfer/chunk/${currentTransferId}?offset=${offset}`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/octet-stream'
                        },
                        body: chunkBytes
                    });

                    if (!chunkResponse.ok) {
                        throw new Error('Failed to send file chunk');
                    }

                    offset += chunkBytes.length;
                    const progress = Math.min(100, Math.round((offset * 100) / currentFile.size));
                    updateFileTransferProgress(progress);
                }

                // Complete file transfer
                const completeResponse = await fetch(`${API_BASE_URL}/api/filetransfer/complete/${currentTransferId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!completeResponse.ok) {
                    throw new Error('Failed to complete file transfer');
                }

                // Notify other clients through SignalR hub
                try {
                    log(`[DEBUG] Invoking FileTransferCompleted hub method for transfer ID: ${currentTransferId}`);
                    await connection.invoke("FileTransferCompleted", currentTransferId);
                    log(`[DEBUG] FileTransferCompleted hub method invoked successfully`);
                } catch (error) {
                    log(`[ERROR] Failed to invoke FileTransferCompleted hub method: ${error.message}`);
                }

                // Don't reset state here - wait for FileTransferCompleted event
                displayResponse('fileTransferStatus', {
                    success: true,
                    message: 'File transfer completed, waiting for download...',
                    code: 'TRANSFER_COMPLETED'
                });

                // Wait for FileTransferCompleted event with a timeout
                const waitForCompletion = new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Timeout waiting for file transfer completion'));
                    }, 30000); // 30 second timeout

                    const handler = (transferId) => {
                        if (transferId === currentTransferId) {
                            clearTimeout(timeout);
                            connection.off("FileTransferCompleted", handler);
                            resolve();
                        }
                    };

                    connection.on("FileTransferCompleted", handler);
                });

                try {
                    await waitForCompletion;
                    log(`[DEBUG] File transfer completion confirmed by SignalR`);
                } catch (error) {
                    log(`[ERROR] Error waiting for file transfer completion: ${error.message}`);
                    throw error;
                }
            } catch (error) {
                displayResponse('fileTransferStatus', {
                    success: false,
                    message: `File transfer failed: ${error.message}`,
                    code: 'TRANSFER_FAILED'
                }, true);
                cancelFileTransfer();
            }
        }

        function cancelFileTransfer() {
            currentFile = null;
            currentTransferId = null;
            document.getElementById('fileInput').value = '';
            document.getElementById('fileTransferProgress').style.display = 'none';
            document.getElementById('downloadButton').style.display = 'none';
            updateFileTransferProgress(0);
        }

        function updateFileTransferProgress(progress) {
            const progressFill = document.querySelector('.progress-fill');
            const progressText = document.querySelector('.progress-text');
            progressFill.style.width = `${progress}%`;
            progressText.textContent = `${progress}%`;
        }

        // Add downloadCompletedFile function
        async function downloadCompletedFile() {
            if (!currentTransferId) {
                log(`[ERROR] No transfer ID available for download`);
                return;
            }

            try {
                log(`[DEBUG] Starting file download for transfer ID: ${currentTransferId}`);
                const response = await fetch(`${API_BASE_URL}/api/filetransfer/download/${currentTransferId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);
                }
                
                log(`[DEBUG] File download successful, creating download link`);
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Get filename from Content-Disposition header
                const contentDisposition = response.headers.get('content-disposition');
                log(`[DEBUG] Content-Disposition header: ${contentDisposition}`);
                let filename = 'downloaded_file';
                
                if (contentDisposition) {
                    // Split by semicolon and find the filename part
                    const parts = contentDisposition.split(';');
                    const filenamePart = parts.find(part => part.trim().startsWith('filename='));
                    if (filenamePart) {
                        filename = filenamePart.split('=')[1].trim();
                        // Remove quotes if present
                        filename = filename.replace(/^["']|["']$/g, '');
                        log(`[DEBUG] Extracted filename: ${filename}`);
                    }
                }
                
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                log(`[DEBUG] File download completed for: ${filename}`);
                displayResponse('fileTransferStatus', {
                    success: true,
                    message: 'File downloaded successfully',
                    code: 'DOWNLOAD_COMPLETED'
                });
                
                // Hide download button after successful download
                document.getElementById('downloadButton').style.display = 'none';
                cancelFileTransfer();
            } catch (error) {
                log(`[ERROR] Error downloading file: ${error.message}`);
                displayResponse('fileTransferStatus', {
                    success: false,
                    message: `Error downloading file: ${error.message}`,
                    code: 'DOWNLOAD_ERROR'
                }, true);
            }
        }

        // Add cryptographic functions
        async function generateKeyPair() {
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: "ECDH",
                    namedCurve: "P-256"
                },
                true,
                ["deriveKey", "deriveBits"]
            );
            return keyPair;
        }

        async function exportPublicKey(keyPair) {
            const exported = await window.crypto.subtle.exportKey(
                "spki",
                keyPair.publicKey
            );
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        async function exportPrivateKey(keyPair) {
            const exported = await window.crypto.subtle.exportKey(
                "pkcs8",
                keyPair.privateKey
            );
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        async function importPublicKey(publicKeyStr) {
            const binary = Uint8Array.from(atob(publicKeyStr), c => c.charCodeAt(0));
            return await window.crypto.subtle.importKey(
                "spki",
                binary,
                {
                    name: "ECDH",
                    namedCurve: "P-256"
                },
                true,
                []
            );
        }

        async function deriveSharedSecret(privateKey, peerPublicKey) {
            const sharedSecret = await window.crypto.subtle.deriveBits(
                {
                    name: "ECDH",
                    public: peerPublicKey
                },
                privateKey,
                256
            );
            return sharedSecret;
        }

        async function deriveAESKey(sharedSecret) {
            return await window.crypto.subtle.importKey(
                "raw",
                sharedSecret,
                { name: "AES-GCM" },
                false,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptData(key, data) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                    tagLength: 128
                },
                key,
                data
            );
            return {
                encrypted: new Uint8Array(encrypted),
                iv: iv
            };
        }

        async function decryptData(key, encryptedData, iv) {
            return await window.crypto.subtle.decrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                    tagLength: 128
                },
                key,
                encryptedData
            );
        }

        // Update WebRTC screen sharing with encryption
        async function startWebRTCScreenSharing() {
            try {
                if (!connection || connection.state !== signalR.HubConnectionState.Connected) {
                    throw new Error('SignalR connection not established');
                }

                const sessionId = document.getElementById('sessionId').value;
                if (!sessionId) {
                    throw new Error('No session ID available');
                }

                // Get the session info to determine peer
                const response = await fetch(`${API_BASE_URL}/api/session/info/${sessionId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    log(`Session info error response: ${errorText}`);
                    throw new Error(`Failed to get session info: ${response.status} ${response.statusText}`);
                }

                let sessionInfo;
                try {
                    const responseText = await response.text();
                    log(`Raw session info response: ${responseText}`);
                    sessionInfo = JSON.parse(responseText);
                } catch (parseError) {
                    log(`Error parsing session info: ${parseError.message}`);
                    throw new Error('Invalid session info response format');
                }

                if (!sessionInfo || !sessionInfo.data) {
                    throw new Error('Invalid session info structure');
                }

                log(`Parsed session info: ${JSON.stringify(sessionInfo)}`);

                // Determine if we are host or client
                const isHost = sessionInfo.data.hostConnectionId === connection.connectionId;
                const peerConnectionId = isHost ? sessionInfo.data.clientConnectionId : sessionInfo.data.hostConnectionId;

                if (!peerConnectionId) {
                    throw new Error('Peer not connected');
                }

                log(`Starting WebRTC with peer: ${peerConnectionId} (${isHost ? 'as host' : 'as client'})`);

                // Generate key pair for this session
                const keyPair = await generateKeyPair();
                const publicKey = await exportPublicKey(keyPair);
                const privateKey = await exportPrivateKey(keyPair);

                // Send public key to peer
                await connection.invoke("ExchangePublicKey", sessionId, peerConnectionId, publicKey);
                log('Public key exchanged');

                // Create peer connection
                peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                // Handle ICE candidates
                peerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        await sendWebRTCSignal('ice-candidate', JSON.stringify(event.candidate));
                    }
                };

                // Get screen stream
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    }
                });

                // Add tracks to peer connection
                screenStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, screenStream);
                });

                // Create and send offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false
                });

                await peerConnection.setLocalDescription(offer);
                await sendWebRTCSignal('offer', JSON.stringify(offer));
                log('WebRTC offer sent');

                // Store private key for later use
                window.currentPrivateKey = privateKey;

                log('WebRTC screen sharing started with encryption');
            } catch (error) {
                log(`Error starting WebRTC screen sharing: ${error.message}`);
                stopWebRTCScreenSharing();
            }
        }

        // Update signal handling
        connection.on("ReceivePublicKey", async (sessionId, peerId, peerPublicKey) => {
            try {
                const importedPublicKey = await importPublicKey(peerPublicKey);
                const sharedSecret = await deriveSharedSecret(
                    await window.crypto.subtle.importKey(
                        "pkcs8",
                        Uint8Array.from(atob(window.currentPrivateKey), c => c.charCodeAt(0)),
                        { name: "ECDH", namedCurve: "P-256" },
                        false,
                        ["deriveKey", "deriveBits"]
                    ),
                    importedPublicKey
                );
                window.sessionKey = await deriveAESKey(sharedSecret);
                await connection.invoke("CompleteKeyExchange", sessionId, peerId);
                log('Key exchange completed successfully');
            } catch (error) {
                log(`Error in key exchange: ${error.message}`);
            }
        });

        // Update data channel handling
        peerConnection.ondatachannel = async (event) => {
            dataChannel = event.channel;
            dataChannel.onmessage = async (event) => {
                try {
                    const data = new Uint8Array(event.data);
                    const iv = data.slice(0, 12);
                    const encryptedData = data.slice(12);
                    const decrypted = await decryptData(window.sessionKey, encryptedData, iv);
                    // Handle decrypted screen data
                    const blob = new Blob([decrypted], { type: 'image/jpeg' });
                    const url = URL.createObjectURL(blob);
                    const img = document.createElement('img');
                    img.src = url;
                    document.getElementById('webrtcScreen').innerHTML = '';
                    document.getElementById('webrtcScreen').appendChild(img);
                } catch (error) {
                    log(`Error decrypting data: ${error.message}`);
                }
            };
        };

        // Update screen capture to use encryption
        async function captureAndEncryptScreen() {
            if (!screenStream || !window.sessionKey) return;

            const video = document.createElement('video');
            video.srcObject = screenStream;
            await new Promise(resolve => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });

            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            const imageData = canvas.toDataURL('image/jpeg', 0.7);
            const binary = Uint8Array.from(atob(imageData.split(',')[1]), c => c.charCodeAt(0));
            
            const { encrypted, iv } = await encryptData(window.sessionKey, binary);
            
            // Combine IV and encrypted data
            const combined = new Uint8Array(iv.length + encrypted.length);
            combined.set(iv);
            combined.set(encrypted, iv.length);
            
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(combined);
            }
        }
    </script>
</body>

</html>